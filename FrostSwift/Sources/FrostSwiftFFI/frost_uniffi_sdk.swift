// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(frost_uniffi_sdkFFI)
import frost_uniffi_sdkFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_frost_uniffi_sdk_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_frost_uniffi_sdk_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
                throw CancellationError()

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}


public protocol DKGPart1ResultProtocol {
    
}

public class DkgPart1Result: DKGPart1ResultProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_frost_uniffi_sdk_fn_free_dkgpart1result(pointer, $0) }
    }

    

    
    
}

public struct FfiConverterTypeDKGPart1Result: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DkgPart1Result

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DkgPart1Result {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DkgPart1Result, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DkgPart1Result {
        return DkgPart1Result(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DkgPart1Result) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeDKGPart1Result_lift(_ pointer: UnsafeMutableRawPointer) throws -> DkgPart1Result {
    return try FfiConverterTypeDKGPart1Result.lift(pointer)
}

public func FfiConverterTypeDKGPart1Result_lower(_ value: DkgPart1Result) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDKGPart1Result.lower(value)
}


public protocol DKGPart2ResultProtocol {
    
}

public class DkgPart2Result: DKGPart2ResultProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_frost_uniffi_sdk_fn_free_dkgpart2result(pointer, $0) }
    }

    

    
    
}

public struct FfiConverterTypeDKGPart2Result: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DkgPart2Result

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DkgPart2Result {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DkgPart2Result, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DkgPart2Result {
        return DkgPart2Result(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DkgPart2Result) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeDKGPart2Result_lift(_ pointer: UnsafeMutableRawPointer) throws -> DkgPart2Result {
    return try FfiConverterTypeDKGPart2Result.lift(pointer)
}

public func FfiConverterTypeDKGPart2Result_lower(_ value: DkgPart2Result) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDKGPart2Result.lower(value)
}


public protocol DKGRound1SecretPackageProtocol {
    
}

public class DkgRound1SecretPackage: DKGRound1SecretPackageProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_frost_uniffi_sdk_fn_free_dkground1secretpackage(pointer, $0) }
    }

    

    
    
}

public struct FfiConverterTypeDKGRound1SecretPackage: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DkgRound1SecretPackage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DkgRound1SecretPackage {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DkgRound1SecretPackage, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DkgRound1SecretPackage {
        return DkgRound1SecretPackage(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DkgRound1SecretPackage) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeDKGRound1SecretPackage_lift(_ pointer: UnsafeMutableRawPointer) throws -> DkgRound1SecretPackage {
    return try FfiConverterTypeDKGRound1SecretPackage.lift(pointer)
}

public func FfiConverterTypeDKGRound1SecretPackage_lower(_ value: DkgRound1SecretPackage) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDKGRound1SecretPackage.lower(value)
}


public protocol DKGRound2SecretPackageProtocol {
    
}

public class DkgRound2SecretPackage: DKGRound2SecretPackageProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_frost_uniffi_sdk_fn_free_dkground2secretpackage(pointer, $0) }
    }

    

    
    
}

public struct FfiConverterTypeDKGRound2SecretPackage: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = DkgRound2SecretPackage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DkgRound2SecretPackage {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: DkgRound2SecretPackage, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> DkgRound2SecretPackage {
        return DkgRound2SecretPackage(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: DkgRound2SecretPackage) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeDKGRound2SecretPackage_lift(_ pointer: UnsafeMutableRawPointer) throws -> DkgRound2SecretPackage {
    return try FfiConverterTypeDKGRound2SecretPackage.lift(pointer)
}

public func FfiConverterTypeDKGRound2SecretPackage_lower(_ value: DkgRound2SecretPackage) -> UnsafeMutableRawPointer {
    return FfiConverterTypeDKGRound2SecretPackage.lower(value)
}


public protocol FrostRandomizedParamsProtocol {
    
}

public class FrostRandomizedParams: FrostRandomizedParamsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_frost_uniffi_sdk_fn_free_frostrandomizedparams(pointer, $0) }
    }

    

    
    
}

public struct FfiConverterTypeFrostRandomizedParams: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FrostRandomizedParams

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FrostRandomizedParams {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FrostRandomizedParams, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FrostRandomizedParams {
        return FrostRandomizedParams(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FrostRandomizedParams) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeFrostRandomizedParams_lift(_ pointer: UnsafeMutableRawPointer) throws -> FrostRandomizedParams {
    return try FfiConverterTypeFrostRandomizedParams.lift(pointer)
}

public func FfiConverterTypeFrostRandomizedParams_lower(_ value: FrostRandomizedParams) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFrostRandomizedParams.lower(value)
}


public protocol OrchardAddressProtocol {
    func stringEncoded()   -> String
    
}

public class OrchardAddress: OrchardAddressProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_frost_uniffi_sdk_fn_free_orchardaddress(pointer, $0) }
    }

    

    public static func newFromString(string: String) throws -> OrchardAddress {
        return OrchardAddress(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeOrchardKeyError.lift) {
    uniffi_frost_uniffi_sdk_fn_constructor_orchardaddress_new_from_string(
        FfiConverterString.lower(string),$0)
})
    }

    

    
    

    public func stringEncoded()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_frost_uniffi_sdk_fn_method_orchardaddress_string_encoded(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeOrchardAddress: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OrchardAddress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OrchardAddress {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: OrchardAddress, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OrchardAddress {
        return OrchardAddress(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: OrchardAddress) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeOrchardAddress_lift(_ pointer: UnsafeMutableRawPointer) throws -> OrchardAddress {
    return try FfiConverterTypeOrchardAddress.lift(pointer)
}

public func FfiConverterTypeOrchardAddress_lower(_ value: OrchardAddress) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOrchardAddress.lower(value)
}


public protocol OrchardCommitIvkRandomnessProtocol {
    func toBytes()   -> Data
    
}

public class OrchardCommitIvkRandomness: OrchardCommitIvkRandomnessProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(bytes: Data) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeOrchardKeyError.lift) {
    uniffi_frost_uniffi_sdk_fn_constructor_orchardcommitivkrandomness_new(
        FfiConverterData.lower(bytes),$0)
})
    }

    deinit {
        try! rustCall { uniffi_frost_uniffi_sdk_fn_free_orchardcommitivkrandomness(pointer, $0) }
    }

    

    
    

    public func toBytes()  -> Data {
        return try!  FfiConverterData.lift(
            try! 
    rustCall() {
    
    uniffi_frost_uniffi_sdk_fn_method_orchardcommitivkrandomness_to_bytes(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeOrchardCommitIvkRandomness: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OrchardCommitIvkRandomness

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OrchardCommitIvkRandomness {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: OrchardCommitIvkRandomness, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OrchardCommitIvkRandomness {
        return OrchardCommitIvkRandomness(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: OrchardCommitIvkRandomness) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeOrchardCommitIvkRandomness_lift(_ pointer: UnsafeMutableRawPointer) throws -> OrchardCommitIvkRandomness {
    return try FfiConverterTypeOrchardCommitIvkRandomness.lift(pointer)
}

public func FfiConverterTypeOrchardCommitIvkRandomness_lower(_ value: OrchardCommitIvkRandomness) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOrchardCommitIvkRandomness.lower(value)
}


public protocol OrchardFullViewingKeyProtocol {
    func ak()   -> OrchardSpendValidatingKey
    func deriveAddress()  throws -> OrchardAddress
    func encode()  throws -> String
    func nk()   -> OrchardNullifierDerivingKey
    func rivk()   -> OrchardCommitIvkRandomness
    
}

public class OrchardFullViewingKey: OrchardFullViewingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_frost_uniffi_sdk_fn_free_orchardfullviewingkey(pointer, $0) }
    }

    

    public static func decode(stringEnconded: String, network: ZcashNetwork) throws -> OrchardFullViewingKey {
        return OrchardFullViewingKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeOrchardKeyError.lift) {
    uniffi_frost_uniffi_sdk_fn_constructor_orchardfullviewingkey_decode(
        FfiConverterString.lower(stringEnconded),
        FfiConverterTypeZcashNetwork.lower(network),$0)
})
    }

    

    public static func newFromCheckedParts(ak: OrchardSpendValidatingKey, nk: OrchardNullifierDerivingKey, rivk: OrchardCommitIvkRandomness, network: ZcashNetwork) throws -> OrchardFullViewingKey {
        return OrchardFullViewingKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeOrchardKeyError.lift) {
    uniffi_frost_uniffi_sdk_fn_constructor_orchardfullviewingkey_new_from_checked_parts(
        FfiConverterTypeOrchardSpendValidatingKey.lower(ak),
        FfiConverterTypeOrchardNullifierDerivingKey.lower(nk),
        FfiConverterTypeOrchardCommitIvkRandomness.lower(rivk),
        FfiConverterTypeZcashNetwork.lower(network),$0)
})
    }

    

    public static func newFromValidatingKeyAndSeed(validatingKey: OrchardSpendValidatingKey, zip32Seed: Data, network: ZcashNetwork) throws -> OrchardFullViewingKey {
        return OrchardFullViewingKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeOrchardKeyError.lift) {
    uniffi_frost_uniffi_sdk_fn_constructor_orchardfullviewingkey_new_from_validating_key_and_seed(
        FfiConverterTypeOrchardSpendValidatingKey.lower(validatingKey),
        FfiConverterData.lower(zip32Seed),
        FfiConverterTypeZcashNetwork.lower(network),$0)
})
    }

    

    
    

    public func ak()  -> OrchardSpendValidatingKey {
        return try!  FfiConverterTypeOrchardSpendValidatingKey.lift(
            try! 
    rustCall() {
    
    uniffi_frost_uniffi_sdk_fn_method_orchardfullviewingkey_ak(self.pointer, $0
    )
}
        )
    }

    public func deriveAddress() throws -> OrchardAddress {
        return try  FfiConverterTypeOrchardAddress.lift(
            try 
    rustCallWithError(FfiConverterTypeOrchardKeyError.lift) {
    uniffi_frost_uniffi_sdk_fn_method_orchardfullviewingkey_derive_address(self.pointer, $0
    )
}
        )
    }

    public func encode() throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeOrchardKeyError.lift) {
    uniffi_frost_uniffi_sdk_fn_method_orchardfullviewingkey_encode(self.pointer, $0
    )
}
        )
    }

    public func nk()  -> OrchardNullifierDerivingKey {
        return try!  FfiConverterTypeOrchardNullifierDerivingKey.lift(
            try! 
    rustCall() {
    
    uniffi_frost_uniffi_sdk_fn_method_orchardfullviewingkey_nk(self.pointer, $0
    )
}
        )
    }

    public func rivk()  -> OrchardCommitIvkRandomness {
        return try!  FfiConverterTypeOrchardCommitIvkRandomness.lift(
            try! 
    rustCall() {
    
    uniffi_frost_uniffi_sdk_fn_method_orchardfullviewingkey_rivk(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeOrchardFullViewingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OrchardFullViewingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OrchardFullViewingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: OrchardFullViewingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OrchardFullViewingKey {
        return OrchardFullViewingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: OrchardFullViewingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeOrchardFullViewingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> OrchardFullViewingKey {
    return try FfiConverterTypeOrchardFullViewingKey.lift(pointer)
}

public func FfiConverterTypeOrchardFullViewingKey_lower(_ value: OrchardFullViewingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOrchardFullViewingKey.lower(value)
}


public protocol OrchardKeyPartsProtocol {
    
}

public class OrchardKeyParts: OrchardKeyPartsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_frost_uniffi_sdk_fn_free_orchardkeyparts(pointer, $0) }
    }

    

    public static func random(network: ZcashNetwork) throws -> OrchardKeyParts {
        return OrchardKeyParts(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeOrchardKeyError.lift) {
    uniffi_frost_uniffi_sdk_fn_constructor_orchardkeyparts_random(
        FfiConverterTypeZcashNetwork.lower(network),$0)
})
    }

    

    
    
}

public struct FfiConverterTypeOrchardKeyParts: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OrchardKeyParts

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OrchardKeyParts {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: OrchardKeyParts, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OrchardKeyParts {
        return OrchardKeyParts(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: OrchardKeyParts) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeOrchardKeyParts_lift(_ pointer: UnsafeMutableRawPointer) throws -> OrchardKeyParts {
    return try FfiConverterTypeOrchardKeyParts.lift(pointer)
}

public func FfiConverterTypeOrchardKeyParts_lower(_ value: OrchardKeyParts) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOrchardKeyParts.lower(value)
}


public protocol OrchardNullifierDerivingKeyProtocol {
    func toBytes()   -> Data
    
}

public class OrchardNullifierDerivingKey: OrchardNullifierDerivingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(bytes: Data) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeOrchardKeyError.lift) {
    uniffi_frost_uniffi_sdk_fn_constructor_orchardnullifierderivingkey_new(
        FfiConverterData.lower(bytes),$0)
})
    }

    deinit {
        try! rustCall { uniffi_frost_uniffi_sdk_fn_free_orchardnullifierderivingkey(pointer, $0) }
    }

    

    
    

    public func toBytes()  -> Data {
        return try!  FfiConverterData.lift(
            try! 
    rustCall() {
    
    uniffi_frost_uniffi_sdk_fn_method_orchardnullifierderivingkey_to_bytes(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeOrchardNullifierDerivingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OrchardNullifierDerivingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OrchardNullifierDerivingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: OrchardNullifierDerivingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OrchardNullifierDerivingKey {
        return OrchardNullifierDerivingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: OrchardNullifierDerivingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeOrchardNullifierDerivingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> OrchardNullifierDerivingKey {
    return try FfiConverterTypeOrchardNullifierDerivingKey.lift(pointer)
}

public func FfiConverterTypeOrchardNullifierDerivingKey_lower(_ value: OrchardNullifierDerivingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOrchardNullifierDerivingKey.lower(value)
}


public protocol OrchardSpendValidatingKeyProtocol {
    func toBytes()   -> Data
    
}

public class OrchardSpendValidatingKey: OrchardSpendValidatingKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_frost_uniffi_sdk_fn_free_orchardspendvalidatingkey(pointer, $0) }
    }

    

    public static func fromBytes(bytes: Data) throws -> OrchardSpendValidatingKey {
        return OrchardSpendValidatingKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeOrchardKeyError.lift) {
    uniffi_frost_uniffi_sdk_fn_constructor_orchardspendvalidatingkey_from_bytes(
        FfiConverterData.lower(bytes),$0)
})
    }

    

    
    

    public func toBytes()  -> Data {
        return try!  FfiConverterData.lift(
            try! 
    rustCall() {
    
    uniffi_frost_uniffi_sdk_fn_method_orchardspendvalidatingkey_to_bytes(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeOrchardSpendValidatingKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = OrchardSpendValidatingKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OrchardSpendValidatingKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: OrchardSpendValidatingKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> OrchardSpendValidatingKey {
        return OrchardSpendValidatingKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: OrchardSpendValidatingKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeOrchardSpendValidatingKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> OrchardSpendValidatingKey {
    return try FfiConverterTypeOrchardSpendValidatingKey.lift(pointer)
}

public func FfiConverterTypeOrchardSpendValidatingKey_lower(_ value: OrchardSpendValidatingKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeOrchardSpendValidatingKey.lower(value)
}


public struct Configuration {
    public var minSigners: UInt16
    public var maxSigners: UInt16
    public var secret: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(minSigners: UInt16, maxSigners: UInt16, secret: Data) {
        self.minSigners = minSigners
        self.maxSigners = maxSigners
        self.secret = secret
    }
}


extension Configuration: Equatable, Hashable {
    public static func ==(lhs: Configuration, rhs: Configuration) -> Bool {
        if lhs.minSigners != rhs.minSigners {
            return false
        }
        if lhs.maxSigners != rhs.maxSigners {
            return false
        }
        if lhs.secret != rhs.secret {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(minSigners)
        hasher.combine(maxSigners)
        hasher.combine(secret)
    }
}


public struct FfiConverterTypeConfiguration: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Configuration {
        return try Configuration(
            minSigners: FfiConverterUInt16.read(from: &buf), 
            maxSigners: FfiConverterUInt16.read(from: &buf), 
            secret: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: Configuration, into buf: inout [UInt8]) {
        FfiConverterUInt16.write(value.minSigners, into: &buf)
        FfiConverterUInt16.write(value.maxSigners, into: &buf)
        FfiConverterData.write(value.secret, into: &buf)
    }
}


public func FfiConverterTypeConfiguration_lift(_ buf: RustBuffer) throws -> Configuration {
    return try FfiConverterTypeConfiguration.lift(buf)
}

public func FfiConverterTypeConfiguration_lower(_ value: Configuration) -> RustBuffer {
    return FfiConverterTypeConfiguration.lower(value)
}


public struct DkgPart3Result {
    public var publicKeyPackage: FrostPublicKeyPackage
    public var keyPackage: FrostKeyPackage

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(publicKeyPackage: FrostPublicKeyPackage, keyPackage: FrostKeyPackage) {
        self.publicKeyPackage = publicKeyPackage
        self.keyPackage = keyPackage
    }
}


extension DkgPart3Result: Equatable, Hashable {
    public static func ==(lhs: DkgPart3Result, rhs: DkgPart3Result) -> Bool {
        if lhs.publicKeyPackage != rhs.publicKeyPackage {
            return false
        }
        if lhs.keyPackage != rhs.keyPackage {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(publicKeyPackage)
        hasher.combine(keyPackage)
    }
}


public struct FfiConverterTypeDKGPart3Result: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DkgPart3Result {
        return try DkgPart3Result(
            publicKeyPackage: FfiConverterTypeFrostPublicKeyPackage.read(from: &buf), 
            keyPackage: FfiConverterTypeFrostKeyPackage.read(from: &buf)
        )
    }

    public static func write(_ value: DkgPart3Result, into buf: inout [UInt8]) {
        FfiConverterTypeFrostPublicKeyPackage.write(value.publicKeyPackage, into: &buf)
        FfiConverterTypeFrostKeyPackage.write(value.keyPackage, into: &buf)
    }
}


public func FfiConverterTypeDKGPart3Result_lift(_ buf: RustBuffer) throws -> DkgPart3Result {
    return try FfiConverterTypeDKGPart3Result.lift(buf)
}

public func FfiConverterTypeDKGPart3Result_lower(_ value: DkgPart3Result) -> RustBuffer {
    return FfiConverterTypeDKGPart3Result.lower(value)
}


public struct DkgRound1Package {
    public var identifier: ParticipantIdentifier
    public var data: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identifier: ParticipantIdentifier, data: Data) {
        self.identifier = identifier
        self.data = data
    }
}


extension DkgRound1Package: Equatable, Hashable {
    public static func ==(lhs: DkgRound1Package, rhs: DkgRound1Package) -> Bool {
        if lhs.identifier != rhs.identifier {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
        hasher.combine(data)
    }
}


public struct FfiConverterTypeDKGRound1Package: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DkgRound1Package {
        return try DkgRound1Package(
            identifier: FfiConverterTypeParticipantIdentifier.read(from: &buf), 
            data: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: DkgRound1Package, into buf: inout [UInt8]) {
        FfiConverterTypeParticipantIdentifier.write(value.identifier, into: &buf)
        FfiConverterData.write(value.data, into: &buf)
    }
}


public func FfiConverterTypeDKGRound1Package_lift(_ buf: RustBuffer) throws -> DkgRound1Package {
    return try FfiConverterTypeDKGRound1Package.lift(buf)
}

public func FfiConverterTypeDKGRound1Package_lower(_ value: DkgRound1Package) -> RustBuffer {
    return FfiConverterTypeDKGRound1Package.lower(value)
}


public struct DkgRound2Package {
    public var identifier: ParticipantIdentifier
    public var data: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identifier: ParticipantIdentifier, data: Data) {
        self.identifier = identifier
        self.data = data
    }
}


extension DkgRound2Package: Equatable, Hashable {
    public static func ==(lhs: DkgRound2Package, rhs: DkgRound2Package) -> Bool {
        if lhs.identifier != rhs.identifier {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
        hasher.combine(data)
    }
}


public struct FfiConverterTypeDKGRound2Package: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DkgRound2Package {
        return try DkgRound2Package(
            identifier: FfiConverterTypeParticipantIdentifier.read(from: &buf), 
            data: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: DkgRound2Package, into buf: inout [UInt8]) {
        FfiConverterTypeParticipantIdentifier.write(value.identifier, into: &buf)
        FfiConverterData.write(value.data, into: &buf)
    }
}


public func FfiConverterTypeDKGRound2Package_lift(_ buf: RustBuffer) throws -> DkgRound2Package {
    return try FfiConverterTypeDKGRound2Package.lift(buf)
}

public func FfiConverterTypeDKGRound2Package_lower(_ value: DkgRound2Package) -> RustBuffer {
    return FfiConverterTypeDKGRound2Package.lower(value)
}


public struct FirstRoundCommitment {
    public var nonces: FrostSigningNonces
    public var commitments: FrostSigningCommitments

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(nonces: FrostSigningNonces, commitments: FrostSigningCommitments) {
        self.nonces = nonces
        self.commitments = commitments
    }
}


extension FirstRoundCommitment: Equatable, Hashable {
    public static func ==(lhs: FirstRoundCommitment, rhs: FirstRoundCommitment) -> Bool {
        if lhs.nonces != rhs.nonces {
            return false
        }
        if lhs.commitments != rhs.commitments {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nonces)
        hasher.combine(commitments)
    }
}


public struct FfiConverterTypeFirstRoundCommitment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FirstRoundCommitment {
        return try FirstRoundCommitment(
            nonces: FfiConverterTypeFrostSigningNonces.read(from: &buf), 
            commitments: FfiConverterTypeFrostSigningCommitments.read(from: &buf)
        )
    }

    public static func write(_ value: FirstRoundCommitment, into buf: inout [UInt8]) {
        FfiConverterTypeFrostSigningNonces.write(value.nonces, into: &buf)
        FfiConverterTypeFrostSigningCommitments.write(value.commitments, into: &buf)
    }
}


public func FfiConverterTypeFirstRoundCommitment_lift(_ buf: RustBuffer) throws -> FirstRoundCommitment {
    return try FfiConverterTypeFirstRoundCommitment.lift(buf)
}

public func FfiConverterTypeFirstRoundCommitment_lower(_ value: FirstRoundCommitment) -> RustBuffer {
    return FfiConverterTypeFirstRoundCommitment.lower(value)
}


public struct FrostKeyPackage {
    public var identifier: ParticipantIdentifier
    public var data: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identifier: ParticipantIdentifier, data: Data) {
        self.identifier = identifier
        self.data = data
    }
}


extension FrostKeyPackage: Equatable, Hashable {
    public static func ==(lhs: FrostKeyPackage, rhs: FrostKeyPackage) -> Bool {
        if lhs.identifier != rhs.identifier {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
        hasher.combine(data)
    }
}


public struct FfiConverterTypeFrostKeyPackage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FrostKeyPackage {
        return try FrostKeyPackage(
            identifier: FfiConverterTypeParticipantIdentifier.read(from: &buf), 
            data: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: FrostKeyPackage, into buf: inout [UInt8]) {
        FfiConverterTypeParticipantIdentifier.write(value.identifier, into: &buf)
        FfiConverterData.write(value.data, into: &buf)
    }
}


public func FfiConverterTypeFrostKeyPackage_lift(_ buf: RustBuffer) throws -> FrostKeyPackage {
    return try FfiConverterTypeFrostKeyPackage.lift(buf)
}

public func FfiConverterTypeFrostKeyPackage_lower(_ value: FrostKeyPackage) -> RustBuffer {
    return FfiConverterTypeFrostKeyPackage.lower(value)
}


public struct FrostPublicKeyPackage {
    public var verifyingShares: [ParticipantIdentifier: String]
    public var verifyingKey: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(verifyingShares: [ParticipantIdentifier: String], verifyingKey: String) {
        self.verifyingShares = verifyingShares
        self.verifyingKey = verifyingKey
    }
}


extension FrostPublicKeyPackage: Equatable, Hashable {
    public static func ==(lhs: FrostPublicKeyPackage, rhs: FrostPublicKeyPackage) -> Bool {
        if lhs.verifyingShares != rhs.verifyingShares {
            return false
        }
        if lhs.verifyingKey != rhs.verifyingKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(verifyingShares)
        hasher.combine(verifyingKey)
    }
}


public struct FfiConverterTypeFrostPublicKeyPackage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FrostPublicKeyPackage {
        return try FrostPublicKeyPackage(
            verifyingShares: FfiConverterDictionaryTypeParticipantIdentifierString.read(from: &buf), 
            verifyingKey: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FrostPublicKeyPackage, into buf: inout [UInt8]) {
        FfiConverterDictionaryTypeParticipantIdentifierString.write(value.verifyingShares, into: &buf)
        FfiConverterString.write(value.verifyingKey, into: &buf)
    }
}


public func FfiConverterTypeFrostPublicKeyPackage_lift(_ buf: RustBuffer) throws -> FrostPublicKeyPackage {
    return try FfiConverterTypeFrostPublicKeyPackage.lift(buf)
}

public func FfiConverterTypeFrostPublicKeyPackage_lower(_ value: FrostPublicKeyPackage) -> RustBuffer {
    return FfiConverterTypeFrostPublicKeyPackage.lower(value)
}


public struct FrostRandomizer {
    public var data: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(data: Data) {
        self.data = data
    }
}


extension FrostRandomizer: Equatable, Hashable {
    public static func ==(lhs: FrostRandomizer, rhs: FrostRandomizer) -> Bool {
        if lhs.data != rhs.data {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(data)
    }
}


public struct FfiConverterTypeFrostRandomizer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FrostRandomizer {
        return try FrostRandomizer(
            data: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: FrostRandomizer, into buf: inout [UInt8]) {
        FfiConverterData.write(value.data, into: &buf)
    }
}


public func FfiConverterTypeFrostRandomizer_lift(_ buf: RustBuffer) throws -> FrostRandomizer {
    return try FfiConverterTypeFrostRandomizer.lift(buf)
}

public func FfiConverterTypeFrostRandomizer_lower(_ value: FrostRandomizer) -> RustBuffer {
    return FfiConverterTypeFrostRandomizer.lower(value)
}


public struct FrostSecretKeyShare {
    public var identifier: ParticipantIdentifier
    public var data: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identifier: ParticipantIdentifier, data: Data) {
        self.identifier = identifier
        self.data = data
    }
}


extension FrostSecretKeyShare: Equatable, Hashable {
    public static func ==(lhs: FrostSecretKeyShare, rhs: FrostSecretKeyShare) -> Bool {
        if lhs.identifier != rhs.identifier {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
        hasher.combine(data)
    }
}


public struct FfiConverterTypeFrostSecretKeyShare: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FrostSecretKeyShare {
        return try FrostSecretKeyShare(
            identifier: FfiConverterTypeParticipantIdentifier.read(from: &buf), 
            data: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: FrostSecretKeyShare, into buf: inout [UInt8]) {
        FfiConverterTypeParticipantIdentifier.write(value.identifier, into: &buf)
        FfiConverterData.write(value.data, into: &buf)
    }
}


public func FfiConverterTypeFrostSecretKeyShare_lift(_ buf: RustBuffer) throws -> FrostSecretKeyShare {
    return try FfiConverterTypeFrostSecretKeyShare.lift(buf)
}

public func FfiConverterTypeFrostSecretKeyShare_lower(_ value: FrostSecretKeyShare) -> RustBuffer {
    return FfiConverterTypeFrostSecretKeyShare.lower(value)
}


public struct FrostSignature {
    public var data: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(data: Data) {
        self.data = data
    }
}


extension FrostSignature: Equatable, Hashable {
    public static func ==(lhs: FrostSignature, rhs: FrostSignature) -> Bool {
        if lhs.data != rhs.data {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(data)
    }
}


public struct FfiConverterTypeFrostSignature: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FrostSignature {
        return try FrostSignature(
            data: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: FrostSignature, into buf: inout [UInt8]) {
        FfiConverterData.write(value.data, into: &buf)
    }
}


public func FfiConverterTypeFrostSignature_lift(_ buf: RustBuffer) throws -> FrostSignature {
    return try FfiConverterTypeFrostSignature.lift(buf)
}

public func FfiConverterTypeFrostSignature_lower(_ value: FrostSignature) -> RustBuffer {
    return FfiConverterTypeFrostSignature.lower(value)
}


public struct FrostSignatureShare {
    public var identifier: ParticipantIdentifier
    public var data: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identifier: ParticipantIdentifier, data: Data) {
        self.identifier = identifier
        self.data = data
    }
}


extension FrostSignatureShare: Equatable, Hashable {
    public static func ==(lhs: FrostSignatureShare, rhs: FrostSignatureShare) -> Bool {
        if lhs.identifier != rhs.identifier {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
        hasher.combine(data)
    }
}


public struct FfiConverterTypeFrostSignatureShare: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FrostSignatureShare {
        return try FrostSignatureShare(
            identifier: FfiConverterTypeParticipantIdentifier.read(from: &buf), 
            data: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: FrostSignatureShare, into buf: inout [UInt8]) {
        FfiConverterTypeParticipantIdentifier.write(value.identifier, into: &buf)
        FfiConverterData.write(value.data, into: &buf)
    }
}


public func FfiConverterTypeFrostSignatureShare_lift(_ buf: RustBuffer) throws -> FrostSignatureShare {
    return try FfiConverterTypeFrostSignatureShare.lift(buf)
}

public func FfiConverterTypeFrostSignatureShare_lower(_ value: FrostSignatureShare) -> RustBuffer {
    return FfiConverterTypeFrostSignatureShare.lower(value)
}


public struct FrostSigningCommitments {
    public var identifier: ParticipantIdentifier
    public var data: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identifier: ParticipantIdentifier, data: Data) {
        self.identifier = identifier
        self.data = data
    }
}


extension FrostSigningCommitments: Equatable, Hashable {
    public static func ==(lhs: FrostSigningCommitments, rhs: FrostSigningCommitments) -> Bool {
        if lhs.identifier != rhs.identifier {
            return false
        }
        if lhs.data != rhs.data {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
        hasher.combine(data)
    }
}


public struct FfiConverterTypeFrostSigningCommitments: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FrostSigningCommitments {
        return try FrostSigningCommitments(
            identifier: FfiConverterTypeParticipantIdentifier.read(from: &buf), 
            data: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: FrostSigningCommitments, into buf: inout [UInt8]) {
        FfiConverterTypeParticipantIdentifier.write(value.identifier, into: &buf)
        FfiConverterData.write(value.data, into: &buf)
    }
}


public func FfiConverterTypeFrostSigningCommitments_lift(_ buf: RustBuffer) throws -> FrostSigningCommitments {
    return try FfiConverterTypeFrostSigningCommitments.lift(buf)
}

public func FfiConverterTypeFrostSigningCommitments_lower(_ value: FrostSigningCommitments) -> RustBuffer {
    return FfiConverterTypeFrostSigningCommitments.lower(value)
}


public struct FrostSigningNonces {
    public var data: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(data: Data) {
        self.data = data
    }
}


extension FrostSigningNonces: Equatable, Hashable {
    public static func ==(lhs: FrostSigningNonces, rhs: FrostSigningNonces) -> Bool {
        if lhs.data != rhs.data {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(data)
    }
}


public struct FfiConverterTypeFrostSigningNonces: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FrostSigningNonces {
        return try FrostSigningNonces(
            data: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: FrostSigningNonces, into buf: inout [UInt8]) {
        FfiConverterData.write(value.data, into: &buf)
    }
}


public func FfiConverterTypeFrostSigningNonces_lift(_ buf: RustBuffer) throws -> FrostSigningNonces {
    return try FfiConverterTypeFrostSigningNonces.lift(buf)
}

public func FfiConverterTypeFrostSigningNonces_lower(_ value: FrostSigningNonces) -> RustBuffer {
    return FfiConverterTypeFrostSigningNonces.lower(value)
}


public struct FrostSigningPackage {
    public var data: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(data: Data) {
        self.data = data
    }
}


extension FrostSigningPackage: Equatable, Hashable {
    public static func ==(lhs: FrostSigningPackage, rhs: FrostSigningPackage) -> Bool {
        if lhs.data != rhs.data {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(data)
    }
}


public struct FfiConverterTypeFrostSigningPackage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FrostSigningPackage {
        return try FrostSigningPackage(
            data: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: FrostSigningPackage, into buf: inout [UInt8]) {
        FfiConverterData.write(value.data, into: &buf)
    }
}


public func FfiConverterTypeFrostSigningPackage_lift(_ buf: RustBuffer) throws -> FrostSigningPackage {
    return try FfiConverterTypeFrostSigningPackage.lift(buf)
}

public func FfiConverterTypeFrostSigningPackage_lower(_ value: FrostSigningPackage) -> RustBuffer {
    return FfiConverterTypeFrostSigningPackage.lower(value)
}


public struct Message {
    public var data: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(data: Data) {
        self.data = data
    }
}


extension Message: Equatable, Hashable {
    public static func ==(lhs: Message, rhs: Message) -> Bool {
        if lhs.data != rhs.data {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(data)
    }
}


public struct FfiConverterTypeMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Message {
        return try Message(
            data: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: Message, into buf: inout [UInt8]) {
        FfiConverterData.write(value.data, into: &buf)
    }
}


public func FfiConverterTypeMessage_lift(_ buf: RustBuffer) throws -> Message {
    return try FfiConverterTypeMessage.lift(buf)
}

public func FfiConverterTypeMessage_lower(_ value: Message) -> RustBuffer {
    return FfiConverterTypeMessage.lower(value)
}


public struct ParticipantIdentifier {
    public var data: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(data: String) {
        self.data = data
    }
}


extension ParticipantIdentifier: Equatable, Hashable {
    public static func ==(lhs: ParticipantIdentifier, rhs: ParticipantIdentifier) -> Bool {
        if lhs.data != rhs.data {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(data)
    }
}


public struct FfiConverterTypeParticipantIdentifier: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParticipantIdentifier {
        return try ParticipantIdentifier(
            data: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ParticipantIdentifier, into buf: inout [UInt8]) {
        FfiConverterString.write(value.data, into: &buf)
    }
}


public func FfiConverterTypeParticipantIdentifier_lift(_ buf: RustBuffer) throws -> ParticipantIdentifier {
    return try FfiConverterTypeParticipantIdentifier.lift(buf)
}

public func FfiConverterTypeParticipantIdentifier_lower(_ value: ParticipantIdentifier) -> RustBuffer {
    return FfiConverterTypeParticipantIdentifier.lower(value)
}


public struct ParticipantList {
    public var identifiers: [ParticipantIdentifier]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(identifiers: [ParticipantIdentifier]) {
        self.identifiers = identifiers
    }
}


extension ParticipantList: Equatable, Hashable {
    public static func ==(lhs: ParticipantList, rhs: ParticipantList) -> Bool {
        if lhs.identifiers != rhs.identifiers {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifiers)
    }
}


public struct FfiConverterTypeParticipantList: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParticipantList {
        return try ParticipantList(
            identifiers: FfiConverterSequenceTypeParticipantIdentifier.read(from: &buf)
        )
    }

    public static func write(_ value: ParticipantList, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeParticipantIdentifier.write(value.identifiers, into: &buf)
    }
}


public func FfiConverterTypeParticipantList_lift(_ buf: RustBuffer) throws -> ParticipantList {
    return try FfiConverterTypeParticipantList.lift(buf)
}

public func FfiConverterTypeParticipantList_lower(_ value: ParticipantList) -> RustBuffer {
    return FfiConverterTypeParticipantList.lower(value)
}


public struct TrustedKeyGeneration {
    public var secretShares: [ParticipantIdentifier: FrostSecretKeyShare]
    public var publicKeyPackage: FrostPublicKeyPackage

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(secretShares: [ParticipantIdentifier: FrostSecretKeyShare], publicKeyPackage: FrostPublicKeyPackage) {
        self.secretShares = secretShares
        self.publicKeyPackage = publicKeyPackage
    }
}


extension TrustedKeyGeneration: Equatable, Hashable {
    public static func ==(lhs: TrustedKeyGeneration, rhs: TrustedKeyGeneration) -> Bool {
        if lhs.secretShares != rhs.secretShares {
            return false
        }
        if lhs.publicKeyPackage != rhs.publicKeyPackage {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(secretShares)
        hasher.combine(publicKeyPackage)
    }
}


public struct FfiConverterTypeTrustedKeyGeneration: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TrustedKeyGeneration {
        return try TrustedKeyGeneration(
            secretShares: FfiConverterDictionaryTypeParticipantIdentifierTypeFrostSecretKeyShare.read(from: &buf), 
            publicKeyPackage: FfiConverterTypeFrostPublicKeyPackage.read(from: &buf)
        )
    }

    public static func write(_ value: TrustedKeyGeneration, into buf: inout [UInt8]) {
        FfiConverterDictionaryTypeParticipantIdentifierTypeFrostSecretKeyShare.write(value.secretShares, into: &buf)
        FfiConverterTypeFrostPublicKeyPackage.write(value.publicKeyPackage, into: &buf)
    }
}


public func FfiConverterTypeTrustedKeyGeneration_lift(_ buf: RustBuffer) throws -> TrustedKeyGeneration {
    return try FfiConverterTypeTrustedKeyGeneration.lift(buf)
}

public func FfiConverterTypeTrustedKeyGeneration_lower(_ value: TrustedKeyGeneration) -> RustBuffer {
    return FfiConverterTypeTrustedKeyGeneration.lower(value)
}

public enum ConfigurationError {

    
    
    case InvalidMaxSigners
    case InvalidMinSigners
    case InvalidIdentifier
    case UnknownError

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeConfigurationError.lift(error)
    }
}


public struct FfiConverterTypeConfigurationError: FfiConverterRustBuffer {
    typealias SwiftType = ConfigurationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConfigurationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidMaxSigners
        case 2: return .InvalidMinSigners
        case 3: return .InvalidIdentifier
        case 4: return .UnknownError

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ConfigurationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .InvalidMaxSigners:
            writeInt(&buf, Int32(1))
        
        
        case .InvalidMinSigners:
            writeInt(&buf, Int32(2))
        
        
        case .InvalidIdentifier:
            writeInt(&buf, Int32(3))
        
        
        case .UnknownError:
            writeInt(&buf, Int32(4))
        
        }
    }
}


extension ConfigurationError: Equatable, Hashable {}

extension ConfigurationError: Error { }

public enum CoordinationError {

    
    
    case FailedToCreateSigningPackage
    case InvalidSigningCommitment
    case IdentifierDeserializationError
    case SigningPackageSerializationError
    case SignatureShareDeserializationError
    case PublicKeyPackageDeserializationError
    case SignatureShareAggregationFailed(message: String)
    case InvalidRandomizer

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeCoordinationError.lift(error)
    }
}


public struct FfiConverterTypeCoordinationError: FfiConverterRustBuffer {
    typealias SwiftType = CoordinationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CoordinationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .FailedToCreateSigningPackage
        case 2: return .InvalidSigningCommitment
        case 3: return .IdentifierDeserializationError
        case 4: return .SigningPackageSerializationError
        case 5: return .SignatureShareDeserializationError
        case 6: return .PublicKeyPackageDeserializationError
        case 7: return .SignatureShareAggregationFailed(
            message: try FfiConverterString.read(from: &buf)
            )
        case 8: return .InvalidRandomizer

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CoordinationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .FailedToCreateSigningPackage:
            writeInt(&buf, Int32(1))
        
        
        case .InvalidSigningCommitment:
            writeInt(&buf, Int32(2))
        
        
        case .IdentifierDeserializationError:
            writeInt(&buf, Int32(3))
        
        
        case .SigningPackageSerializationError:
            writeInt(&buf, Int32(4))
        
        
        case .SignatureShareDeserializationError:
            writeInt(&buf, Int32(5))
        
        
        case .PublicKeyPackageDeserializationError:
            writeInt(&buf, Int32(6))
        
        
        case let .SignatureShareAggregationFailed(message):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(message, into: &buf)
            
        
        case .InvalidRandomizer:
            writeInt(&buf, Int32(8))
        
        }
    }
}


extension CoordinationError: Equatable, Hashable {}

extension CoordinationError: Error { }

public enum FrostError {

    
    
    case InvalidMinSigners
    case InvalidMaxSigners
    case InvalidCoefficients
    case MalformedIdentifier
    case DuplicatedIdentifier
    case UnknownIdentifier
    case IncorrectNumberOfIdentifiers
    case MalformedSigningKey
    case MalformedVerifyingKey
    case MalformedSignature
    case InvalidSignature
    case DuplicatedShares
    case IncorrectNumberOfShares
    case IdentityCommitment
    case MissingCommitment
    case IncorrectCommitment
    case IncorrectNumberOfCommitments
    case InvalidSignatureShare(culprit: ParticipantIdentifier)
    case InvalidSecretShare
    case PackageNotFound
    case IncorrectNumberOfPackages
    case IncorrectPackage
    case DkgNotSupported
    case InvalidProofOfKnowledge(culprit: ParticipantIdentifier)
    case FieldError(message: String)
    case GroupError(message: String)
    case InvalidCoefficient
    case IdentifierDerivationNotSupported
    case SerializationError
    case DeserializationError
    case DkgPart2IncorrectNumberOfCommitments
    case DkgPart2IncorrectNumberOfPackages
    case DkgPart3IncorrectRound1Packages
    case DkgPart3IncorrectNumberOfPackages
    case DkgPart3PackageSendersMismatch
    case InvalidKeyPackage
    case InvalidSecretKey
    case InvalidConfiguration
    case UnexpectedError

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeFrostError.lift(error)
    }
}


public struct FfiConverterTypeFrostError: FfiConverterRustBuffer {
    typealias SwiftType = FrostError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FrostError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidMinSigners
        case 2: return .InvalidMaxSigners
        case 3: return .InvalidCoefficients
        case 4: return .MalformedIdentifier
        case 5: return .DuplicatedIdentifier
        case 6: return .UnknownIdentifier
        case 7: return .IncorrectNumberOfIdentifiers
        case 8: return .MalformedSigningKey
        case 9: return .MalformedVerifyingKey
        case 10: return .MalformedSignature
        case 11: return .InvalidSignature
        case 12: return .DuplicatedShares
        case 13: return .IncorrectNumberOfShares
        case 14: return .IdentityCommitment
        case 15: return .MissingCommitment
        case 16: return .IncorrectCommitment
        case 17: return .IncorrectNumberOfCommitments
        case 18: return .InvalidSignatureShare(
            culprit: try FfiConverterTypeParticipantIdentifier.read(from: &buf)
            )
        case 19: return .InvalidSecretShare
        case 20: return .PackageNotFound
        case 21: return .IncorrectNumberOfPackages
        case 22: return .IncorrectPackage
        case 23: return .DkgNotSupported
        case 24: return .InvalidProofOfKnowledge(
            culprit: try FfiConverterTypeParticipantIdentifier.read(from: &buf)
            )
        case 25: return .FieldError(
            message: try FfiConverterString.read(from: &buf)
            )
        case 26: return .GroupError(
            message: try FfiConverterString.read(from: &buf)
            )
        case 27: return .InvalidCoefficient
        case 28: return .IdentifierDerivationNotSupported
        case 29: return .SerializationError
        case 30: return .DeserializationError
        case 31: return .DkgPart2IncorrectNumberOfCommitments
        case 32: return .DkgPart2IncorrectNumberOfPackages
        case 33: return .DkgPart3IncorrectRound1Packages
        case 34: return .DkgPart3IncorrectNumberOfPackages
        case 35: return .DkgPart3PackageSendersMismatch
        case 36: return .InvalidKeyPackage
        case 37: return .InvalidSecretKey
        case 38: return .InvalidConfiguration
        case 39: return .UnexpectedError

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FrostError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .InvalidMinSigners:
            writeInt(&buf, Int32(1))
        
        
        case .InvalidMaxSigners:
            writeInt(&buf, Int32(2))
        
        
        case .InvalidCoefficients:
            writeInt(&buf, Int32(3))
        
        
        case .MalformedIdentifier:
            writeInt(&buf, Int32(4))
        
        
        case .DuplicatedIdentifier:
            writeInt(&buf, Int32(5))
        
        
        case .UnknownIdentifier:
            writeInt(&buf, Int32(6))
        
        
        case .IncorrectNumberOfIdentifiers:
            writeInt(&buf, Int32(7))
        
        
        case .MalformedSigningKey:
            writeInt(&buf, Int32(8))
        
        
        case .MalformedVerifyingKey:
            writeInt(&buf, Int32(9))
        
        
        case .MalformedSignature:
            writeInt(&buf, Int32(10))
        
        
        case .InvalidSignature:
            writeInt(&buf, Int32(11))
        
        
        case .DuplicatedShares:
            writeInt(&buf, Int32(12))
        
        
        case .IncorrectNumberOfShares:
            writeInt(&buf, Int32(13))
        
        
        case .IdentityCommitment:
            writeInt(&buf, Int32(14))
        
        
        case .MissingCommitment:
            writeInt(&buf, Int32(15))
        
        
        case .IncorrectCommitment:
            writeInt(&buf, Int32(16))
        
        
        case .IncorrectNumberOfCommitments:
            writeInt(&buf, Int32(17))
        
        
        case let .InvalidSignatureShare(culprit):
            writeInt(&buf, Int32(18))
            FfiConverterTypeParticipantIdentifier.write(culprit, into: &buf)
            
        
        case .InvalidSecretShare:
            writeInt(&buf, Int32(19))
        
        
        case .PackageNotFound:
            writeInt(&buf, Int32(20))
        
        
        case .IncorrectNumberOfPackages:
            writeInt(&buf, Int32(21))
        
        
        case .IncorrectPackage:
            writeInt(&buf, Int32(22))
        
        
        case .DkgNotSupported:
            writeInt(&buf, Int32(23))
        
        
        case let .InvalidProofOfKnowledge(culprit):
            writeInt(&buf, Int32(24))
            FfiConverterTypeParticipantIdentifier.write(culprit, into: &buf)
            
        
        case let .FieldError(message):
            writeInt(&buf, Int32(25))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .GroupError(message):
            writeInt(&buf, Int32(26))
            FfiConverterString.write(message, into: &buf)
            
        
        case .InvalidCoefficient:
            writeInt(&buf, Int32(27))
        
        
        case .IdentifierDerivationNotSupported:
            writeInt(&buf, Int32(28))
        
        
        case .SerializationError:
            writeInt(&buf, Int32(29))
        
        
        case .DeserializationError:
            writeInt(&buf, Int32(30))
        
        
        case .DkgPart2IncorrectNumberOfCommitments:
            writeInt(&buf, Int32(31))
        
        
        case .DkgPart2IncorrectNumberOfPackages:
            writeInt(&buf, Int32(32))
        
        
        case .DkgPart3IncorrectRound1Packages:
            writeInt(&buf, Int32(33))
        
        
        case .DkgPart3IncorrectNumberOfPackages:
            writeInt(&buf, Int32(34))
        
        
        case .DkgPart3PackageSendersMismatch:
            writeInt(&buf, Int32(35))
        
        
        case .InvalidKeyPackage:
            writeInt(&buf, Int32(36))
        
        
        case .InvalidSecretKey:
            writeInt(&buf, Int32(37))
        
        
        case .InvalidConfiguration:
            writeInt(&buf, Int32(38))
        
        
        case .UnexpectedError:
            writeInt(&buf, Int32(39))
        
        }
    }
}


extension FrostError: Equatable, Hashable {}

extension FrostError: Error { }

public enum FrostSignatureVerificationError {

    
    
    case InvalidPublicKeyPackage
    case ValidationFailed(reason: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeFrostSignatureVerificationError.lift(error)
    }
}


public struct FfiConverterTypeFrostSignatureVerificationError: FfiConverterRustBuffer {
    typealias SwiftType = FrostSignatureVerificationError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FrostSignatureVerificationError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidPublicKeyPackage
        case 2: return .ValidationFailed(
            reason: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FrostSignatureVerificationError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .InvalidPublicKeyPackage:
            writeInt(&buf, Int32(1))
        
        
        case let .ValidationFailed(reason):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(reason, into: &buf)
            
        }
    }
}


extension FrostSignatureVerificationError: Equatable, Hashable {}

extension FrostSignatureVerificationError: Error { }

public enum OrchardKeyError {

    
    
    case KeyDerivationError(message: String)
    case SerializationError
    case DeserializationError
    case OtherError(errorMessage: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeOrchardKeyError.lift(error)
    }
}


public struct FfiConverterTypeOrchardKeyError: FfiConverterRustBuffer {
    typealias SwiftType = OrchardKeyError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OrchardKeyError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .KeyDerivationError(
            message: try FfiConverterString.read(from: &buf)
            )
        case 2: return .SerializationError
        case 3: return .DeserializationError
        case 4: return .OtherError(
            errorMessage: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OrchardKeyError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .KeyDerivationError(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)
            
        
        case .SerializationError:
            writeInt(&buf, Int32(2))
        
        
        case .DeserializationError:
            writeInt(&buf, Int32(3))
        
        
        case let .OtherError(errorMessage):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(errorMessage, into: &buf)
            
        }
    }
}


extension OrchardKeyError: Equatable, Hashable {}

extension OrchardKeyError: Error { }

public enum Round1Error {

    
    
    case InvalidKeyPackage
    case NonceSerializationError
    case CommitmentSerializationError

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeRound1Error.lift(error)
    }
}


public struct FfiConverterTypeRound1Error: FfiConverterRustBuffer {
    typealias SwiftType = Round1Error

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Round1Error {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidKeyPackage
        case 2: return .NonceSerializationError
        case 3: return .CommitmentSerializationError

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Round1Error, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .InvalidKeyPackage:
            writeInt(&buf, Int32(1))
        
        
        case .NonceSerializationError:
            writeInt(&buf, Int32(2))
        
        
        case .CommitmentSerializationError:
            writeInt(&buf, Int32(3))
        
        }
    }
}


extension Round1Error: Equatable, Hashable {}

extension Round1Error: Error { }

public enum Round2Error {

    
    
    case InvalidKeyPackage
    case NonceSerializationError
    case CommitmentSerializationError
    case SigningPackageDeserializationError
    case SigningFailed(message: String)
    case InvalidRandomizer

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeRound2Error.lift(error)
    }
}


public struct FfiConverterTypeRound2Error: FfiConverterRustBuffer {
    typealias SwiftType = Round2Error

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Round2Error {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidKeyPackage
        case 2: return .NonceSerializationError
        case 3: return .CommitmentSerializationError
        case 4: return .SigningPackageDeserializationError
        case 5: return .SigningFailed(
            message: try FfiConverterString.read(from: &buf)
            )
        case 6: return .InvalidRandomizer

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Round2Error, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .InvalidKeyPackage:
            writeInt(&buf, Int32(1))
        
        
        case .NonceSerializationError:
            writeInt(&buf, Int32(2))
        
        
        case .CommitmentSerializationError:
            writeInt(&buf, Int32(3))
        
        
        case .SigningPackageDeserializationError:
            writeInt(&buf, Int32(4))
        
        
        case let .SigningFailed(message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(message, into: &buf)
            
        
        case .InvalidRandomizer:
            writeInt(&buf, Int32(6))
        
        }
    }
}


extension Round2Error: Equatable, Hashable {}

extension Round2Error: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ZcashNetwork {
    
    case mainnet
    case testnet
}

public struct FfiConverterTypeZcashNetwork: FfiConverterRustBuffer {
    typealias SwiftType = ZcashNetwork

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZcashNetwork {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .mainnet
        
        case 2: return .testnet
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ZcashNetwork, into buf: inout [UInt8]) {
        switch value {
        
        
        case .mainnet:
            writeInt(&buf, Int32(1))
        
        
        case .testnet:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeZcashNetwork_lift(_ buf: RustBuffer) throws -> ZcashNetwork {
    return try FfiConverterTypeZcashNetwork.lift(buf)
}

public func FfiConverterTypeZcashNetwork_lower(_ value: ZcashNetwork) -> RustBuffer {
    return FfiConverterTypeZcashNetwork.lower(value)
}


extension ZcashNetwork: Equatable, Hashable {}



fileprivate struct FfiConverterOptionTypeParticipantIdentifier: FfiConverterRustBuffer {
    typealias SwiftType = ParticipantIdentifier?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeParticipantIdentifier.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeParticipantIdentifier.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceTypeFrostSignatureShare: FfiConverterRustBuffer {
    typealias SwiftType = [FrostSignatureShare]

    public static func write(_ value: [FrostSignatureShare], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFrostSignatureShare.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FrostSignatureShare] {
        let len: Int32 = try readInt(&buf)
        var seq = [FrostSignatureShare]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFrostSignatureShare.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeFrostSigningCommitments: FfiConverterRustBuffer {
    typealias SwiftType = [FrostSigningCommitments]

    public static func write(_ value: [FrostSigningCommitments], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFrostSigningCommitments.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FrostSigningCommitments] {
        let len: Int32 = try readInt(&buf)
        var seq = [FrostSigningCommitments]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFrostSigningCommitments.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeParticipantIdentifier: FfiConverterRustBuffer {
    typealias SwiftType = [ParticipantIdentifier]

    public static func write(_ value: [ParticipantIdentifier], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeParticipantIdentifier.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ParticipantIdentifier] {
        let len: Int32 = try readInt(&buf)
        var seq = [ParticipantIdentifier]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeParticipantIdentifier.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryTypeParticipantIdentifierString: FfiConverterRustBuffer {
    public static func write(_ value: [ParticipantIdentifier: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeParticipantIdentifier.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ParticipantIdentifier: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [ParticipantIdentifier: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeParticipantIdentifier.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypeParticipantIdentifierTypeDKGRound1Package: FfiConverterRustBuffer {
    public static func write(_ value: [ParticipantIdentifier: DkgRound1Package], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeParticipantIdentifier.write(key, into: &buf)
            FfiConverterTypeDKGRound1Package.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ParticipantIdentifier: DkgRound1Package] {
        let len: Int32 = try readInt(&buf)
        var dict = [ParticipantIdentifier: DkgRound1Package]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeParticipantIdentifier.read(from: &buf)
            let value = try FfiConverterTypeDKGRound1Package.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypeParticipantIdentifierTypeDKGRound2Package: FfiConverterRustBuffer {
    public static func write(_ value: [ParticipantIdentifier: DkgRound2Package], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeParticipantIdentifier.write(key, into: &buf)
            FfiConverterTypeDKGRound2Package.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ParticipantIdentifier: DkgRound2Package] {
        let len: Int32 = try readInt(&buf)
        var dict = [ParticipantIdentifier: DkgRound2Package]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeParticipantIdentifier.read(from: &buf)
            let value = try FfiConverterTypeDKGRound2Package.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryTypeParticipantIdentifierTypeFrostSecretKeyShare: FfiConverterRustBuffer {
    public static func write(_ value: [ParticipantIdentifier: FrostSecretKeyShare], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeParticipantIdentifier.write(key, into: &buf)
            FfiConverterTypeFrostSecretKeyShare.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ParticipantIdentifier: FrostSecretKeyShare] {
        let len: Int32 = try readInt(&buf)
        var dict = [ParticipantIdentifier: FrostSecretKeyShare]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeParticipantIdentifier.read(from: &buf)
            let value = try FfiConverterTypeFrostSecretKeyShare.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

public func aggregate(signingPackage: FrostSigningPackage, signatureShares: [FrostSignatureShare], pubkeyPackage: FrostPublicKeyPackage, randomizer: FrostRandomizer) throws -> FrostSignature {
    return try  FfiConverterTypeFrostSignature.lift(
        try rustCallWithError(FfiConverterTypeCoordinationError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_aggregate(
        FfiConverterTypeFrostSigningPackage.lower(signingPackage),
        FfiConverterSequenceTypeFrostSignatureShare.lower(signatureShares),
        FfiConverterTypeFrostPublicKeyPackage.lower(pubkeyPackage),
        FfiConverterTypeFrostRandomizer.lower(randomizer),$0)
}
    )
}

public func commitmentToJson(commitment: FrostSigningCommitments) throws -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeFrostError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_commitment_to_json(
        FfiConverterTypeFrostSigningCommitments.lower(commitment),$0)
}
    )
}

public func fromHexString(hexString: String) throws -> FrostRandomizer {
    return try  FfiConverterTypeFrostRandomizer.lift(
        try rustCallWithError(FfiConverterTypeFrostError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_from_hex_string(
        FfiConverterString.lower(hexString),$0)
}
    )
}

public func generateNoncesAndCommitments(keyPackage: FrostKeyPackage) throws -> FirstRoundCommitment {
    return try  FfiConverterTypeFirstRoundCommitment.lift(
        try rustCallWithError(FfiConverterTypeRound1Error.lift) {
    uniffi_frost_uniffi_sdk_fn_func_generate_nonces_and_commitments(
        FfiConverterTypeFrostKeyPackage.lower(keyPackage),$0)
}
    )
}

public func identifierFromJsonString(string: String)  -> ParticipantIdentifier? {
    return try!  FfiConverterOptionTypeParticipantIdentifier.lift(
        try! rustCall() {
    uniffi_frost_uniffi_sdk_fn_func_identifier_from_json_string(
        FfiConverterString.lower(string),$0)
}
    )
}

public func identifierFromString(string: String) throws -> ParticipantIdentifier {
    return try  FfiConverterTypeParticipantIdentifier.lift(
        try rustCallWithError(FfiConverterTypeFrostError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_identifier_from_string(
        FfiConverterString.lower(string),$0)
}
    )
}

public func identifierFromUint16(unsignedUint: UInt16) throws -> ParticipantIdentifier {
    return try  FfiConverterTypeParticipantIdentifier.lift(
        try rustCallWithError(FfiConverterTypeFrostError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_identifier_from_uint16(
        FfiConverterUInt16.lower(unsignedUint),$0)
}
    )
}

public func jsonToCommitment(commitmentJson: String, identifier: ParticipantIdentifier) throws -> FrostSigningCommitments {
    return try  FfiConverterTypeFrostSigningCommitments.lift(
        try rustCallWithError(FfiConverterTypeFrostError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_json_to_commitment(
        FfiConverterString.lower(commitmentJson),
        FfiConverterTypeParticipantIdentifier.lower(identifier),$0)
}
    )
}

public func jsonToKeyPackage(keyPackageJson: String) throws -> FrostKeyPackage {
    return try  FfiConverterTypeFrostKeyPackage.lift(
        try rustCallWithError(FfiConverterTypeFrostError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_json_to_key_package(
        FfiConverterString.lower(keyPackageJson),$0)
}
    )
}

public func jsonToPublicKeyPackage(publicKeyPackageJson: String) throws -> FrostPublicKeyPackage {
    return try  FfiConverterTypeFrostPublicKeyPackage.lift(
        try rustCallWithError(FfiConverterTypeFrostError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_json_to_public_key_package(
        FfiConverterString.lower(publicKeyPackageJson),$0)
}
    )
}

public func jsonToRandomizer(randomizerJson: String) throws -> FrostRandomizer {
    return try  FfiConverterTypeFrostRandomizer.lift(
        try rustCallWithError(FfiConverterTypeFrostError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_json_to_randomizer(
        FfiConverterString.lower(randomizerJson),$0)
}
    )
}

public func jsonToSignatureShare(signatureShareJson: String, identifier: ParticipantIdentifier) throws -> FrostSignatureShare {
    return try  FfiConverterTypeFrostSignatureShare.lift(
        try rustCallWithError(FfiConverterTypeFrostError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_json_to_signature_share(
        FfiConverterString.lower(signatureShareJson),
        FfiConverterTypeParticipantIdentifier.lower(identifier),$0)
}
    )
}

public func keyPackageToJson(keyPackage: FrostKeyPackage) throws -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeFrostError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_key_package_to_json(
        FfiConverterTypeFrostKeyPackage.lower(keyPackage),$0)
}
    )
}

public func newSigningPackage(message: Message, commitments: [FrostSigningCommitments]) throws -> FrostSigningPackage {
    return try  FfiConverterTypeFrostSigningPackage.lift(
        try rustCallWithError(FfiConverterTypeCoordinationError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_new_signing_package(
        FfiConverterTypeMessage.lower(message),
        FfiConverterSequenceTypeFrostSigningCommitments.lower(commitments),$0)
}
    )
}

public func part1(participantIdentifier: ParticipantIdentifier, maxSigners: UInt16, minSigners: UInt16) throws -> DkgPart1Result {
    return try  FfiConverterTypeDKGPart1Result.lift(
        try rustCallWithError(FfiConverterTypeFrostError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_part_1(
        FfiConverterTypeParticipantIdentifier.lower(participantIdentifier),
        FfiConverterUInt16.lower(maxSigners),
        FfiConverterUInt16.lower(minSigners),$0)
}
    )
}

public func part2(secretPackage: DkgRound1SecretPackage, round1Packages: [ParticipantIdentifier: DkgRound1Package]) throws -> DkgPart2Result {
    return try  FfiConverterTypeDKGPart2Result.lift(
        try rustCallWithError(FfiConverterTypeFrostError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_part_2(
        FfiConverterTypeDKGRound1SecretPackage.lower(secretPackage),
        FfiConverterDictionaryTypeParticipantIdentifierTypeDKGRound1Package.lower(round1Packages),$0)
}
    )
}

public func part3(secretPackage: DkgRound2SecretPackage, round1Packages: [ParticipantIdentifier: DkgRound1Package], round2Packages: [ParticipantIdentifier: DkgRound2Package]) throws -> DkgPart3Result {
    return try  FfiConverterTypeDKGPart3Result.lift(
        try rustCallWithError(FfiConverterTypeFrostError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_part_3(
        FfiConverterTypeDKGRound2SecretPackage.lower(secretPackage),
        FfiConverterDictionaryTypeParticipantIdentifierTypeDKGRound1Package.lower(round1Packages),
        FfiConverterDictionaryTypeParticipantIdentifierTypeDKGRound2Package.lower(round2Packages),$0)
}
    )
}

public func publicKeyPackageToJson(publicKeyPackage: FrostPublicKeyPackage) throws -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeFrostError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_public_key_package_to_json(
        FfiConverterTypeFrostPublicKeyPackage.lower(publicKeyPackage),$0)
}
    )
}

public func randomizedParamsFromPublicKeyAndSigningPackage(publicKey: FrostPublicKeyPackage, signingPackage: FrostSigningPackage) throws -> FrostRandomizedParams {
    return try  FfiConverterTypeFrostRandomizedParams.lift(
        try rustCallWithError(FfiConverterTypeFrostError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_randomized_params_from_public_key_and_signing_package(
        FfiConverterTypeFrostPublicKeyPackage.lower(publicKey),
        FfiConverterTypeFrostSigningPackage.lower(signingPackage),$0)
}
    )
}

public func randomizerFromParams(randomizedParams: FrostRandomizedParams) throws -> FrostRandomizer {
    return try  FfiConverterTypeFrostRandomizer.lift(
        try rustCallWithError(FfiConverterTypeFrostError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_randomizer_from_params(
        FfiConverterTypeFrostRandomizedParams.lower(randomizedParams),$0)
}
    )
}

public func randomizerToJson(randomizer: FrostRandomizer) throws -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeFrostError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_randomizer_to_json(
        FfiConverterTypeFrostRandomizer.lower(randomizer),$0)
}
    )
}

public func sign(signingPackage: FrostSigningPackage, nonces: FrostSigningNonces, keyPackage: FrostKeyPackage, randomizer: FrostRandomizer) throws -> FrostSignatureShare {
    return try  FfiConverterTypeFrostSignatureShare.lift(
        try rustCallWithError(FfiConverterTypeRound2Error.lift) {
    uniffi_frost_uniffi_sdk_fn_func_sign(
        FfiConverterTypeFrostSigningPackage.lower(signingPackage),
        FfiConverterTypeFrostSigningNonces.lower(nonces),
        FfiConverterTypeFrostKeyPackage.lower(keyPackage),
        FfiConverterTypeFrostRandomizer.lower(randomizer),$0)
}
    )
}

public func signatureSharePackageToJson(signatureShare: FrostSignatureShare) throws -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeFrostError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_signature_share_package_to_json(
        FfiConverterTypeFrostSignatureShare.lower(signatureShare),$0)
}
    )
}

public func trustedDealerKeygenFrom(configuration: Configuration) throws -> TrustedKeyGeneration {
    return try  FfiConverterTypeTrustedKeyGeneration.lift(
        try rustCallWithError(FfiConverterTypeFrostError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_trusted_dealer_keygen_from(
        FfiConverterTypeConfiguration.lower(configuration),$0)
}
    )
}

public func trustedDealerKeygenWithIdentifiers(configuration: Configuration, participants: ParticipantList) throws -> TrustedKeyGeneration {
    return try  FfiConverterTypeTrustedKeyGeneration.lift(
        try rustCallWithError(FfiConverterTypeFrostError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_trusted_dealer_keygen_with_identifiers(
        FfiConverterTypeConfiguration.lower(configuration),
        FfiConverterTypeParticipantList.lower(participants),$0)
}
    )
}

public func validateConfig(config: Configuration) throws {
    try rustCallWithError(FfiConverterTypeConfigurationError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_validate_config(
        FfiConverterTypeConfiguration.lower(config),$0)
}
}



public func verifyAndGetKeyPackageFrom(secretShare: FrostSecretKeyShare) throws -> FrostKeyPackage {
    return try  FfiConverterTypeFrostKeyPackage.lift(
        try rustCallWithError(FfiConverterTypeFrostError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_verify_and_get_key_package_from(
        FfiConverterTypeFrostSecretKeyShare.lower(secretShare),$0)
}
    )
}

public func verifyRandomizedSignature(randomizer: FrostRandomizer, message: Message, signature: FrostSignature, pubkey: FrostPublicKeyPackage) throws {
    try rustCallWithError(FfiConverterTypeFrostSignatureVerificationError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_verify_randomized_signature(
        FfiConverterTypeFrostRandomizer.lower(randomizer),
        FfiConverterTypeMessage.lower(message),
        FfiConverterTypeFrostSignature.lower(signature),
        FfiConverterTypeFrostPublicKeyPackage.lower(pubkey),$0)
}
}



public func verifySignature(message: Message, signature: FrostSignature, pubkey: FrostPublicKeyPackage) throws {
    try rustCallWithError(FfiConverterTypeFrostSignatureVerificationError.lift) {
    uniffi_frost_uniffi_sdk_fn_func_verify_signature(
        FfiConverterTypeMessage.lower(message),
        FfiConverterTypeFrostSignature.lower(signature),
        FfiConverterTypeFrostPublicKeyPackage.lower(pubkey),$0)
}
}



private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 24
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_frost_uniffi_sdk_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_aggregate() != 3424) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_commitment_to_json() != 12818) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_from_hex_string() != 29801) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_generate_nonces_and_commitments() != 1477) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_identifier_from_json_string() != 56485) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_identifier_from_string() != 3795) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_identifier_from_uint16() != 11722) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_json_to_commitment() != 62453) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_json_to_key_package() != 58769) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_json_to_public_key_package() != 8036) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_json_to_randomizer() != 47111) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_json_to_signature_share() != 62549) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_key_package_to_json() != 11157) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_new_signing_package() != 50111) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_part_1() != 7592) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_part_2() != 30136) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_part_3() != 31134) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_public_key_package_to_json() != 20437) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_randomized_params_from_public_key_and_signing_package() != 58556) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_randomizer_from_params() != 50217) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_randomizer_to_json() != 23719) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_sign() != 723) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_signature_share_package_to_json() != 2249) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_trusted_dealer_keygen_from() != 43563) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_trusted_dealer_keygen_with_identifiers() != 49159) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_validate_config() != 26688) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_verify_and_get_key_package_from() != 16387) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_verify_randomized_signature() != 24114) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_func_verify_signature() != 13620) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_method_orchardaddress_string_encoded() != 38758) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_method_orchardcommitivkrandomness_to_bytes() != 54004) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_method_orchardfullviewingkey_ak() != 1900) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_method_orchardfullviewingkey_derive_address() != 26015) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_method_orchardfullviewingkey_encode() != 34271) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_method_orchardfullviewingkey_nk() != 33472) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_method_orchardfullviewingkey_rivk() != 25054) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_method_orchardnullifierderivingkey_to_bytes() != 8783) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_method_orchardspendvalidatingkey_to_bytes() != 10051) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_constructor_orchardaddress_new_from_string() != 64287) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_constructor_orchardcommitivkrandomness_new() != 55160) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_constructor_orchardfullviewingkey_decode() != 6758) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_constructor_orchardfullviewingkey_new_from_checked_parts() != 19481) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_constructor_orchardfullviewingkey_new_from_validating_key_and_seed() != 62836) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_constructor_orchardkeyparts_random() != 3046) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_constructor_orchardnullifierderivingkey_new() != 15347) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_frost_uniffi_sdk_checksum_constructor_orchardspendvalidatingkey_from_bytes() != 63121) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}